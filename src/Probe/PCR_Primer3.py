print 'Import PCR.py'
import os
import sys
import math
import time
from string import maketrans, join

#TODO: rewrite this re-integrate

import FASTA as FA
import nCluster as CL
import MolBio as MB
import BLAST as BL
import ProbeDesignFunctions as PD
import ListManipulator as LM
import Useability as US
import probe as PROBE
location = {}
DEBUG = None
#####################Functions

def ParsePrimer3(PrimerOUT_IFN, location, InGetVals = []):
    UD = location['WorkDir']
    OFN = FA.path([UD, 'Parsed_'+PrimerOUT_IFN.fn], fileType = 'tab')
    PrimerOUT_IFN.type = 'raw'
    inBuff = PrimerOUT_IFN.inDB()
    RunLst = inBuff.split('\n=\n')
    GetVals = ['PRIMER_SEQUENCE_ID',
               'SEQUENCE',
               'PRIMER_LEFT_SEQUENCE',
               'PRIMER_RIGHT_SEQUENCE',
               'PRIMER_LEFT_TM',
               'PRIMER_RIGHT_TM',
               'PRIMER_LEFT_GC_PERCENT',
               'PRIMER_RIGHT_GC_PERCENT',
               'PRIMER_LEFT',
               'PRIMER_RIGHT',
               'PRIMER_LEFT_1_SEQUENCE',
               'PRIMER_RIGHT_1_SEQUENCE',
               'PRIMER_LEFT_1_TM',
               'PRIMER_RIGHT_1_TM',
               'PRIMER_LEFT_1_GC_PERCENT',
               'PRIMER_RIGHT_1_GC_PERCENT',
               'PRIMER_LEFT_1',
               'PRIMER_RIGHT_1']
    for Retreive_Val in InGetVals:
        if not(Retreive_Val in GetVals):
            GetVals.append(Retreive_Val)
    LL = ['runIndex'] + copy.deepcopy(GetVals) + ['PCRFRAG_Seq', 'PD_Start', 'PD_End', 'PD_Label', 'PD_Seq', 'lenPD_Seq']
    outDB = []
    runIndex = 0
    for robj in RunLst:
        runObj = robj.split('\n')
        runDict = {}
        runIndex +=1
        FailedRun = None
        for outputline in runObj:
            lineSplit = outputline.split('=')
            if len(lineSplit) ==2:
                q, val  = lineSplit
                q = q.strip()
                runDict[q] = val.strip()
        outObj = [runIndex]
        for query in GetVals:
            if query in runDict:
                outObj.append(runDict[query])
            else:
                outObj.append('missing')
                FailedRun = 1
        if FailedRun ==None:
            seq = runDict['SEQUENCE']
            Fprimer = runDict['PRIMER_LEFT_SEQUENCE']
            ASRprimer = MB.Antisense(runDict['PRIMER_RIGHT_SEQUENCE'])
            start = seq.find(Fprimer)
            end = seq.find(ASRprimer) + len(ASRprimer)
            subSeq = seq[start:end]
            PDstart = start + len(Fprimer)
            PDend = end - len(ASRprimer)
            pdseq = seq[PDstart:PDend]
            label = runDict['PRIMER_SEQUENCE_ID']
            if not(label[-1] =='|'):
                label = label + '|'
            pdLabel = label + 'pd-'+str(PDstart) + '-' + str(PDend)
            outObj = outObj + [subSeq, PDstart, PDend, pdLabel, pdseq, len(pdseq)]
        else:
            outObj.append('FAILEDRUN')
            outObj[0] = 'fail'
        if FailedRun and runDict:
            print 'This run Failed %s'%runDict['PRIMER_SEQUENCE_ID']
        outDB.append(outObj)
    outDB = [LL] + outDB
    OFN.outDB(outDB)
    return OFN
    

def RunPrimer3(IFNorLst, location, INSettingsDict = {}, OFN_PATHorpath = None, root = 'generic'):
    """RunPrimer3: Runs Primer 3
    |IFN_PATHorpath, OFN_PATHorpath
    |Output: OFN the output is primer3-type output further processing is neccessary
    |
    ||"""
    UD = location['WorkDir']
    if 'list' in str(type(IFNorLst)):
        inDB = IFNorLst
    else:
        inDB = IFNorLst.inDB()
    
    Primer3_IFN = FA.path([UD, 'primer3_%s_infile.txt' %root], fileType = 'raw')
    ofp = Primer3_IFN.FP(RW='w')
    SettingsDict = {
        'PRIMER_PRODUCT_SIZE_RANGE':'180-250',
        'PRIMER_OPT_SIZE':'19',
        'PRIMER_MIN_SIZE':'17',
        'PRIMER_MAX_SIZE':'25',
        'PRIMER_WARNING':'s (*)',
        'PRIMER_MIN_TM':'52',
        'PRIMER_OPT_TM':'55',
        'PRIMER_MAX_TM':'56',
        'PRIMER_TM_SANTALUCIA':'1',
        'PRIMER_SALT_CORRECTIONS':'1',
        'PRIMER_PRODUCT_TM_OLIGO_TM_DIFF':'1.0',
        'PRIMER_GC_CLAMP':'2',}
    SettingsDict.update(INSettingsDict)
    Settings = [key + '=' + SettingsDict[key] for key in SettingsDict.keys()]
    settingsStr = '\n'.join(Settings)
    for seqObj in inDB:
        primerseqid = seqObj[0]
        seq = seqObj[1]
        outStr = 'PRIMER_SEQUENCE_ID = %s\nSEQUENCE=%s\n%s\n=\n' %(primerseqid, seq,settingsStr)
        outStr = outStr + ''
        ofp.write(outStr)
    ofp.close()
    
    return RunPrimer3BatFile(Primer3_IFN, location, OFN_PATHorpath=OFN_PATHorpath)


def RunPrimer3BatFile(IFN_PATHorpath, location, OFN_PATHorpath=None):
    """RunPrimer3BatFile: Runs Primer 3
    |IFN_PATHorpath, OFN_PATHorpath
    |Output: OFN
    |Needs special input generated by RunPrimer3
    |Property of RunPrimer3
    |"""
    subRoutineDir = location['subRoutineDir']
    UD = location['WorkDir']
    
    IFN_PATH = FA.path(IFN_PATHorpath)
    if not(OFN_PATHorpath):
        OFN_PATH = FA.path([UD, 'Primer3OUT_' + IFN_PATH.fn], fileType = 'raw')
    else:
        OFN_PATH = FA.path(OFN_PATHorpath)
    INpath = IFN_PATH.p
    OUTpath = OFN_PATH.p
    RunString = '%sprimer3_core.exe <%s >%s' %(subRoutineDir, INpath, OUTpath)
    batPath = UD + 'generic_primer3Run.bat'
    bf = open(batPath,'w')
    bf.write(RunString)
    bf.write('\n')
    bf.close()
    if sys.platform == 'linux2':
        os.chmod(batPath,os.X_OK)
    os.chdir(UD)
    if sys.platform == 'linux2':
        os.chmod(batPath ,os.X_OK)
        y = os.popen(batPath)
        y.close()
    else:
        x = os.spawnv(os.P_WAIT,batPath,['',])
    return OFN_PATH




def HitParser(inHits,b):
    """HitParser: Exclusive Property of PCR function
    |inHits,b
    |Output: copy
    |
    ||"""
    maxscore = 0
    BU_Hits = LM.ListBreakup(inHits,b['score'])
    for obj in BU_Hits:
        score = obj[0][b['score']]
        if score > maxscore:
            useList = obj
            maxscore= score
    if len(useList)>1:
        useList.sort(lambda x,y,b: cmp(int(x[b['qend']]),int(y[b['qend']])))
    chooseHit = useList[-1]
    getList = ['query','align','sstart','send','score']
    outList = []
    for obj in getList:
        outList.append(chooseHit[b[obj]])
    outList[2] = int(outList[2])
    outList[3] = int(outList[3])
    return outList
import copy


def FixedHitParser(inHits,b,alignCutOff = None):
    """FixedHitParser: Exclusive Property of PCR function
    |inHits,b
    |Output: copy
    |
    ||"""
    #Breaks up sequence by best score
    maxscore = 0
    useList = []
    chooseList = []
    keepHits = []
    # here's an excellent place to apply a cut-off          
    if alignCutOff:
        for h in range(len(inHits)):
            #print inHits[h][b['align']]
            if int(inHits[h][b['align']]) > alignCutOff:
                keepHits.append(inHits[h][:])                 
        if len(keepHits) ==0:
            return []
        else:
            inHits[:] = keepHits
    BU_Hits = LM.ListBreakup(inHits,b['score'])
    #find best score
    while BU_Hits:
        i_ = 0
        maxscore = 0
        for obj in BU_Hits:
            score = float(obj[0][b['score']])
            if score > maxscore:
                useList = obj[:]
                maxscore= score
                i_i = i_
            i_ +=1
        #This looks for oligos that terminate furthest 3' within themselves
        del BU_Hits[i_i]
        #this one looks for oligo that matches furthest 3'
        sortIndex = b['qend']
        useList.sort(lambda x, y: cmp(int(x[sortIndex]),int(y[sortIndex])))
        chooseList.append(useList[-1])
    return chooseList

def CompareForRev(forHits,revHits,b,approxFragSize = None):
    """CompareForRev: Exclusive Property of PCR function
    |forHits,revHits,b,approxFragSize = None
    |Output: forHits[F_index],revHits[R_index] or None, None
    |
    ||"""
    forBox = []
    revBox = []
    F_index = None
    R_index = None
    frags = []
    i = 0
    for obj in forHits:
        forBox.append([int(obj[b['sstart']]),i,int(obj[b['score']])])
        i += 1
    i = 0
    for obj in revHits:
        revBox.append([int(obj[b['sstart']]),i,int(obj[b['score']])])
        i += 1
    #These are already sorted best to worst
    #This part creates every F-R combination that results in a PCR fragment
    for p in forBox:
        fpos = int(p[0])
        for r in revBox:
            rpos = int(r[0])
            pcrFragSize = rpos -fpos
            if pcrFragSize > 20:
                frags.append([pcrFragSize,p[1],r[1],p[2]+r[2]])
                F_index = p[1]
                R_index = r[1]     
    if F_index:
        if approxFragSize:
            #The one closest to approxFragSize is chosen
            Maxdiff = 999999999
            for frag in frags:
                fragSize = frag[0]
                diff = abs(fragSize - approxFragSize)
                if diff < Maxdiff:
                    Maxdiff = diff
                    chosenFrag = frag      
        else:#pick best sum of F and R scores
            frags.sort(lambda x,y: cmp(x[3],y[3]))
            chosenFrag = frags[-1]
        F_index = chosenFrag[1]
        R_index = chosenFrag[2]   
        return forHits[F_index],revHits[R_index]
    else:
        return None, None
b = {'query':0,'subject':1,'%id':2,'align':3,'mm':4,'gap':5,'qstart':6,'qend':7,'sstart':8,'send':9,'e':10,'score':11}
        
def ExtractHit(chooseHit, getList = ['query','align','sstart','send','score']):
    """ExtractHit: Exclusive Property of PCR function
    |Input: ChooseHit,chooseHit, getList = ['query','align','sstart','send','score']
    |
    |
    ||"""
    outList = []
    for obj in getList:
        outList.append(chooseHit[b[obj]])
    outList[2] = int(outList[2])
    outList[3] = int(outList[3])
    return outList


def getSeq(subjectSeq,interval,extra):
    """getSeq: Exclusive property of PCR function
    |Input: subjectSeq,interval,extra
    |Output: outSeq
    |
    ||"""
    i = min(interval)
    j = max(interval)
    if i-extra < 0:
            i = 0
    outSeq = subjectSeq[i-extra:i].lower() + subjectSeq[i:j].upper() + subjectSeq[j:j+extra].lower()
    return outSeq




def MarkSeqInSeq(seq, subseq, AS=0):
    if AS: subseq = MB.Antisense(subseq)
    seq = seq.lower().strip()
    subseq = subseq.lower().strip()
    start = seq.find(subseq)
    subseq = subseq.upper()
    end = start + len(subseq)-1
    outStr = ''
    j = 0
    for i in range(len(seq)):
        if i<start or i > end:
            outStr = outStr + seq[i]
        else:
            outStr = outStr + subseq[i-start]
    return outStr

def StrReverse(string):
    sL = list(string)
    sL.reverse()
    return  ''.join(sL)

def DistanceFromEnd(seq, subseq):
    seq = StrReverse(seq).lower()
    subseq = StrReverse(subseq).lower()
    return seq.find(subseq)

def computePrimerDimer(testSeq, otherProbe, location, testSeqLength = 8, mm = -3, gapopen = -5, gapextend = -2, Gap = None):
    subRoutineDir = location['subRoutineDir']
    UD = location['WorkDir']
    #This requires Derisis's energy program in subroutine directory [send this 'c:\pythonCore\']look at Derisi's program oligoarray
    p_line = testSeq[-1*testSeqLength:]
    m_line = MB.Antisense(otherProbe)
    
    if not(Gap) and len(p_line) == len(m_line):
        queryHitSeq, subjHitSeq = [p_line, m_line]
    else:
        queryHitSeq, subjHitSeq = MB.SW(p_line,m_line, MM = mm, gapOpen = gapopen, gapExtend = gapextend, Verbose = None)
    energy = (MB.dG(queryHitSeq) + MB.dG(subjHitSeq))/2
    f= os.popen(subRoutineDir + 'energy ' + queryHitSeq + ' ' + subjHitSeq + ' 1')
    ##In reverting you are correctly antisensing the oppsoite strand. It is not
    ## Real antisensing as the sequence is not flipped it is simply changed in place
    ## GATTC becomes CTAAG
    retData = f.read()
    f.close()
    if 'WARNING:' in retData:
        energy = 0.0
    else:
        energy =  float(retData.split('\n') [-1])
    
    distFromEnd = DistanceFromEnd(testSeq, queryHitSeq)
    otherProbe = MarkSeqInSeq(otherProbe, subjHitSeq, AS = 1)
    testSeq = MarkSeqInSeq(testSeq, queryHitSeq)
    return energy, testSeq, otherProbe, queryHitSeq, subjHitSeq, distFromEnd, testSeqLength

def FASTComputePrimerDimer(testSeq, otherProbe, testSeqLength = 8, mm = -3, gapopen = -5, gapextend = -2, Gap = None):
    ##This is a Hack, it Does not use energy program from DeRissi
    
    p_line = testSeq[-1*testSeqLength:]
    m_line = MB.Antisense(otherProbe)
    
    if not(Gap) and len(p_line) == len(m_line):
        queryHitSeq, subjectHitSeq = [p_line, m_line]
    else:
        queryHitSeq, subjectHitSeq = MB.SW(p_line,m_line, MM = mm, gapOpen = gapopen, gapExtend = gapextend, Verbose = None)
    energy = MB.computeFreeEnergyHack(queryHitSeq, subjectHitSeq)   ###avg(MB.dG(queryHitSeq), MB.dG(subjHitSeq))

    distFromEnd = DistanceFromEnd(testSeq, queryHitSeq)
    otherProbe = MarkSeqInSeq(otherProbe, subjectHitSeq, AS = 1)
    testSeq = MarkSeqInSeq(testSeq, queryHitSeq)
    return energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, testSeqLength


def MakePrimerDimerGrid(inLstorPATH = None):
    seqList = FA.InLstOrPath(inLstorPATH = inLstorPATH , FileQuery = 'Get Primer File', defaultfn = '*.*', defaulttype = 'fasta')

    SM = [[0 for i in range(len(seqList))]for i in range(len(seqList))]
    SeqM = [['' for i in range(len(seqList))]for i in range(len(seqList))]
    jlabels = ['']
    for i in range(len(seqList)):
        faObji = seqList[i]
        ilabel, iseq = faObji[:2]
        jlabels.append(ilabel)
        for j in range(len(seqList)):
            faObjj = seqList[j]
            jlabel, jseq = faObjj[:2]
            PDOUT_a = FASTComputePrimerDimer(iseq, jseq, testSeqLength = 8, mm = -3, gapopen = -5, gapextend = -2, Gap = None)
            PDOUT_b = FASTComputePrimerDimer(jseq, iseq, testSeqLength = 8, mm = -3, gapopen = -5, gapextend = -2, Gap = None)
            score_a = ScorePrimerDimer(PDOUT_a)
            score_b = ScorePrimerDimer(PDOUT_b)
            
            if score_a > score_b:
                score = score_a
                PDOUT = PDOUT_a
            else:
                score = score_b
                PDOUT = PDOUT_b
            energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, testSeqLength = PDOUT
            SM[i][j] = score
            SeqM[i][j] = testSeq#queryHitSeq + '_' + subjectHitSeq
            print '(%i,%i) of %i   \n%s\n%s\n\n' %(i,j,len(seqList), str(score), SeqM[i][j])
        SM[i] = [ilabel] + SM[i]
        SeqM[i] = [ilabel] + SeqM[i]
    SM = [jlabels] + SM + [['seq' for i in range(len(seqList))]] + SeqM
    return SM


def ScorePrimerDimer(PDOUT):
    energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, testSeqLength = PDOUT
    Match = 0
    for i in range(len(subjectHitSeq)):
        if subjectHitSeq[i] == queryHitSeq[i]:
            Match +=1
    if Match < 4: Match = 0
    score = Match*1000
    endDistFactor = 0
    if distFromEnd == 0:
        endDistFactor = 10
    if distFromEnd == 1:
        endDistFactor = 5
    if distFromEnd == 2:
        endDistFactor = 1
    score = score * endDistFactor
    score = score + -1*(energy)
    return score

def ComputeSelfPrimerDimer(seq, other = None, pairdbOUT= None):
    if other ==None:
        other = seq
    PDOUT = FASTComputePrimerDimer(seq, other, testSeqLength = 8, mm = -1, gapopen = -3, gapextend = -2, Gap = None)

    energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, testSeqLength = PDOUT
    score = ScorePrimerDimer(PDOUT)
    if pairdbOUT:
        return 'nolabel', seq, 'nolabel', seq, energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, score
    else:
        return score, testSeq, otherProbe

def ForwardPCRFilter(seq, Forward = 1):
    if Forward:
        testseq = seq[-6:]
    else:
        testseq = seq[:6]
    percg = MB.perGC(testseq)
    if  percg > 40.0 and percg < 60.0:
        return True
    else:
        print 'PCRFilter rejected %s at %.2f' %(seq, percg)
        return False
def ReversePCRFilter(seq, Forward = 0):
    if Forward:
        testseq = seq[-6:]
    else:
        testseq = seq[:6]
    percg = MB.perGC(testseq)
    if   percg > 40.0 and percg < 60.0:
        return True
    else:
        print 'PCRFilter rejected %s at %.2f' %(seq, percg)
        return False


def returnAccessFunction(index):
    if 'int' in str(type(index)):
        runstr = "reFunct = lambda x:x[%i]" %index
        exec runstr
        return reFunct
    elif 'function' in str(type(index)):
        return index
    else:
        raise 'returnAccessFunction: Invalid indexer'
             
   
def MUX(PrimerIFN, location, labelIndex = 0, seqIndex = 1, DataStart = 1):
    #Takes a list of primers and computes interaction matrix
    #It appends matrix to list of primers. Assumes fasta type (ie [label, seq, len, .... other items ... ,,])
    subRoutineDir = location['subRoutineDir']
    UD = location['WorkDir']
    root = PrimerIFN.root
    inDB = PrimerIFN.inDB()
    if DataStart ==1:
        LL = inDB.pop(0)
    else:
        LL = ['nolabel' for i in range(len(inDB[0]))]
    primerDB = []
    primerNumber = DataStart
    for sobj in inDB:
        primerDB.append([primerNumber, sobj[seqIndex], len(sobj[seqIndex])])
        primerNumber +=1

    SM = CL.SimilarityMatrix(Similarity = 0, MAX = None, MIN = None)
    pairDB = [['testProbeLabel', 'r_seq', 'c_seqLabel', 'c_seq', 'deltaG', 'testSeq', 'otherProbe','q', 's', 'distFromEnd(r_seq, q)', 'Score']]
    
    t = US.ReportTimer(len(primerDB), ReportInterval = 1, ProcessName = 'generating SW:')
    for r in range(len(primerDB)):
        t(r)
        for c in range(len(primerDB)):
            r_seq = primerDB[r][1]
            c_seq = primerDB[c][1]
            PDOUT = computePrimerDimer(r_seq, c_seq, location, testSeqLength = 8, mm = -1, gapopen = -3, gapextend = -2, Gap = None)
            energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, testSeqLength = PDOUT
            score = ScorePrimerDimer(PDOUT)
            SM[r][c] = score
            pairDB.append([primerDB[r][0], r_seq, primerDB[c][0], c_seq, energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, score])
    PairDB_IFN = FA.path([UD, 'Pairdb_%s_T.txt'%root])
    PairDB_IFN.outDB(pairDB)
    HuReadable = SM.HumanReadable()
    
    
    for i in range(len(inDB)):
        intMatrixRow = ['Hit->' , i] +  HuReadable[i]
        inDB[i].extend(intMatrixRow)

    LL.extend(['',''])
    LL.extend([i for i in range(SM.n)])
    inDB = [LL] + inDB
    
    SMDB_IFN = FA.path([UD, 'SM_%s_T.txt'%root])
    SMDB_IFN.outDB(inDB)
    return SM, SMDB_IFN, PairDB_IFN




PCRDesignParameters = {'type':1, 		##irrelevant
                  'strict':None,	##irrelevant
                  'parseLabelType':100,	##irrelevant Can be lambdaFunction
                  'ProbeType':'PCR',	##irrelevant
                  'TmMin':60,		##<-- relevant
                  'MaxSynthCycles':150, ##<---relevant for synthesis
                  'MinLen':19,	##<-- relevant
                  'MaxLen':28,	##<-- relevant, max is 40
                  'MaxGC':65,		##irrelevant
                  'MinGC':35,		##irrelevant
                  'half':None,	##Exclusive: Tiling parameter start half-way through previous probe
                  'overlap':None,	##Exclusive: Tiling parameter start x bases before end of previous probe
                  'startIncrement':1,	##Exclusive: Tiling parameter start 11 bases after start of previous probe
                  'MaxHPTm':55,		##irrelevant: Hairpin max Tm
                  'MaxPalindrome':55,	##irrelevant: Palindrom Max Tm 
                  'MaxRepeats':6,		##irrelevant: Max number of repeats 3.1 is TTT repeats 3.2 is TATATA
                  'CaptureEnd': 1,		##See Note below
              'ProbeStartNumber' : 0	##For labelling purposes only
            }

class PCRAmplicon:
    ##fULL SERVICE AMPLICON OBJECT
    ##Usage
    # pcObj = PCRAmplicon('mylabel')
    #psObj.DeasignPrimers('gatggctagtcgatc', gctagctagtcgatcgatgcta', PCRparams = {})
    def __init__(self, ampLabel, ampSeq = '', forlabel = '',Fprimer = '', revlabel = '', Rprimer = ''):
        self.label = ampLabel
        self.ampSeq = ampSeq.upper() #this is the whole seqeunce from which the primers are to be designed
        self.forPrimer = Fprimer
        self.revPrimer = Rprimer
        self.forlabel = forlabel
        self.revlabel = revlabel
        self.primerdimer_FR_Score = None
        self.calc()
        #self.inseq = '' #this is the whole seqeunce from which the primers are to be designed
    def calc(self):
        if self.forPrimer and self.revPrimer:#don't really need amplicon sequence at all
            self.FindPrimersInSeq()
            self.primerdimer_FR_Score = ComputeSelfPrimerDimer(self.forPrimer, other = self.revPrimer, pairdbOUT= None)
            self.forPrimerObj = PROBE.probeObject([self.forlabel,self.forPrimer, len(self.forPrimer), 0.0, 0, 0, self.label, self.label])
            self.revPrimerObj = PROBE.probeObject([self.revlabel,self.revPrimer, len(self.revPrimer), 0.0, 0, 0, self.label, self.label])
        
    def DesignPrimers(self, leftSeq, rightSeq, PCRparams = {}, scoreMatrix= {}):
        ScoreMatrix = {'HP':1000,'PD':10000,'GC':10000,'rep':10000,'Tm':100,'PCRGC':10000, 'self-Anneal':2}
        ScoreMatrix.update(scoreMatrix)
        params = copy.deepcopy(PCRDesignParameters)
        params.update(PCRparams)
        F_TBTDB = [['For|' + self.label, leftSeq.upper(), len(leftSeq)]]
        R_TBTDB = [['Rev|' + self.label, MB.Antisense(rightSeq.upper()), len(rightSeq)]]
        
        F_tiledDBObj = PD.TilerObject(F_TBTDB, PCRDesignParameters, Verbose = 0)
        R_tiledDBObj = PD.TilerObject(R_TBTDB, PCRDesignParameters, Verbose = 0) 
        F_tiledDBObj.TBalanced()
        R_tiledDBObj.TBalanced()
        fpo, rpo, score = ChooseNonPrimerDimer(F_tiledDBObj, R_tiledDBObj, ScoreMatrix)
        #fpo, rpo = tiledDBObj.RenderBestNSeqs(1, scoreMatrix = scoremat, returnObject = 0)
        self.primerdimer_FR_Score = score
        self.forPrimerObj = fpo
        self.revPrimerObj = rpo
        self.forPrimer = self.forPrimerObj.seq
        self.revPrimer = self.revPrimerObj.seq
        self.forlabel = self.forPrimerObj.label
        self.revlabel = self.revPrimerObj.label
        self.FindPrimersInSeq()
    def ImportPrimerThree(self, inline):
        ##This is output from my routine PCR.ParsePrimer3
        runIndex, PRIMER_SEQUENCE_ID, SEQUENCE, PRIMER_LEFT_SEQUENCE, PRIMER_RIGHT_SEQUENCE, PRIMER_LEFT_TM, PRIMER_RIGHT_TM, PRIMER_LEFT_GC_PERCENT, PRIMER_RIGHT_GC_PERCENT, PRIMER_LEFT, PRIMER_RIGHT, PRIMER_LEFT_1_SEQUENCE, PRIMER_RIGHT_1_SEQUENCE, PRIMER_LEFT_1_TM, PRIMER_RIGHT_1_TM, PRIMER_LEFT_1_GC_PERCENT, PRIMER_RIGHT_1_GC_PERCENT, PRIMER_LEFT_1, PRIMER_RIGHT_1, PCRFRAG_Seq, PD_Start, PD_End, PD_Label, PD_Seq, lenPD_Seq = inline[:25]
        self.label = PRIMER_SEQUENCE_ID
        self.inseq = SEQUENCE
        self.forPrimer = PRIMER_LEFT_SEQUENCE
        self.revPrimer = PRIMER_RIGHT_SEQUENCE
        self.forlabel = 'FOR|%s|sl%s' %(self.label,PRIMER_LEFT.replace(',','-'))
        self.revlabel = 'REV|%s|sl%s' %(self.label,PRIMER_Right.replace(',','-'))
        #label,sequence,probeLen,probeTm, Start,End,LabelRoot,OrigFASTALabel
        self.forPrimerObj = PROBE.probeObject([self.forlabel, self.forPrimer, 20,0.0, 0,0, PRIMER_SEQUENCE_ID, PRIMER_SEQUENCE_ID])
        self.revPrimerObj = PROBE.probeObject([self.revlabel, self.revPrimer, 20,0.0, 0,0, PRIMER_SEQUENCE_ID, PRIMER_SEQUENCE_ID])
        self.forPrimerObj.Tm = MB.PCRTm(self.forPrimer)
    def AdjustPrimer(self,seq, Tm):  
        return MB.AdjustProbeTmTo(seq, dTm = Tm, addToFivePrime = 1, RemoveFromFivePrime = 1,Verbose = 1)
    def AdjustForPrimer(self, Tm):  
        self.forPrimer = MB.AdjustProbeTmTo(self.forPrimer, dTm = Tm, addToFivePrime = 1, RemoveFromFivePrime = 1,Verbose = 1)
        self.forPrimerObj.seq = self.forPrimer
        self.forPrimerObj.characterize()
    def AdjustRevPrimer(self,Tm):  
        self.revPrimer = MB.AdjustProbeTmTo(self.revPrimer, dTm = Tm, addToFivePrime = 1, RemoveFromFivePrime = 1,Verbose = 1)
        self.revPrimerObj.seq = self.revPrimer
        self.revPrimerObj.characterize()
    def FindPrimersInSeq(self):
        fullseq = self.ampSeq
        s = fullseq.lower().find(self.forPrimer.lower())
        if s ==-1:
            start = 0
        else:
            start = s
        e = fullseq.lower().find(MB.Antisense(self.revPrimer.lower()))
        if e ==-1:
            end = len(fullseq)
        else:
            end = e + len(self.revPrimer)
        if (s == -1) or (e ==-1):
            self.AmplifiedSeq =  'NOTFOUND-' + self.ampSeq + '-NOTFOUND'
            print 'FindPrimersInSeq: did not find\n%s\t%i\n%s\t%i\n in:\n%s' %(self.forPrimer, s, self.revPrimer, e, fullseq)
        self.AmplifiedSeq = fullseq[start:end]
        self.ampStart = start
        self.ampEnd = end
        self.ampLength = end-start
    def InputFromOutput(self, inobj):
##      Ampliconlabel
##      AmpliconSeq
##      AmpliconLen
##      For-Rev_PrimerDimer
##      label_for
##      Primer_for
##      PCRTm_for
##      failreason_for
##      label_rev
##      Primer_rev
##      PCRTm_rev
##      failreason_rev
        self.label=inobj[0]
        self.AmplifiedSeq=inobj[1]
        self.ampLength=int(inobj[2])
        self.primerdimer_FR_Score=inobj[3]
        self.forlabel=inobj[4]
        self.forPrimer=inobj[5]
        self.revlabel=inobj[8]
        self.revPrimer=inobj[9]
        self.calc()
        
    def outDB(self, LL = None):
        if LL:
             return ['Ampliconlabel',
                     'AmpliconSeq',
                     'AmpliconLen',
                     'For-Rev_PrimerDimer',
                'label_for',
                'Primer_for',
                'PCRTm_for',
                'failreason_for',
                'label_rev',
                'Primer_rev',
                'PCRTm_rev',
                'failreason_rev',]
        else:
            return [self.label,
                    self.AmplifiedSeq,
                    self.ampLength,
                    self.primerdimer_FR_Score,
                self.forlabel,
                self.forPrimer,
                MB.PCRTm(self.forPrimer),
                self.forPrimerObj.failreason,
                self.revlabel,
                self.revPrimer,
                MB.PCRTm(self.revPrimer),
                self.revPrimerObj.failreason]
    

def ChooseNonPrimerDimer(F_tiledDBObj, R_tiledDBObj, pdThreshold = 30000, ScoreMatrix = {}, maxRunCycles = 10):
    #assumed thet tiledDBObjects have been probeDB()'d
    Choicedepth = 1
    stillLooking = 1
    cycle = 1
    while stillLooking and cycle < maxRunCycles:
        cycle +=1
        F_POLst = F_tiledDBObj.RenderBestNSeqs(Choicedepth, scoreMatrix = ScoreMatrix, returnObject = 1)
        R_POLst = R_tiledDBObj.RenderBestNSeqs(Choicedepth, scoreMatrix = ScoreMatrix, returnObject = 1)
        pairDB = []
        for f in range(Choicedepth):
            for r in range(Choicedepth):
                pobjPD_score = ComputProbeObjPrimerDimer(F_POLst[f], R_POLst[r])
                score = pobjPD_score + F_POLst[f].score + R_POLst[r].score
                pairDB.append([f,r,score])
                
        pairDB.sort(lambda x,y:cmp(x[-1],y[-1]))
        bestPair = pairDB[0]
        if bestPair[2] > pdThreshold:
            Choicedepth +=1
            print 'ChooseNonPrimerDimer: is going deeper: level %i' %Choicedepth
        else:
            break
    f, r, finalscore = bestPair
    #print 'For label %s RevLabel %s' %(F_POLst[f].label, R_POLst[r].label)
    return F_POLst[f], R_POLst[r], score

def ComputProbeObjPrimerDimer(pObj_a, pObj_b):                       
    f_seq = pObj_a.seq
    r_seq = pObj_b.seq
    PDOUT = computePrimerDimer(f_seq, r_seq, location, testSeqLength = 8, mm = -1, gapopen = -3, gapextend = -2, Gap = None)
    score = ScorePrimerDimer(PDOUT)
    return score

 
def ComputAmpObjPrimerDimer(AmpObj_a, AmpObj_b, location):
    primerLst = [AmpObj_a.forPrimer , AmpObj_a.revPrimer , AmpObj_b.forPrimer, AmpObj_b.revPrimer]
    labelLst = [AmpObj_a.forlabel , AmpObj_a.revlabel , AmpObj_b.forlabel, AmpObj_b.revlabel]
    scoreLst = []
    matrixSize = len(primerLst)
    #the 0, 1 and 2,3 is os that this particular metric does not count FRprimer-dimers This is captured elsewhere.
    for r in [0,1]:
        for c in [2,3]:
            r_seq = primerLst[r]
            r_lab = labelLst[r]
            c_seq = primerLst[c]
            c_lab = labelLst[c]
            PDOUT = computePrimerDimer(r_seq, c_seq, location, testSeqLength = 8, mm = -1, gapopen = -3, gapextend = -2, Gap = None)
            score = ScorePrimerDimer(PDOUT)
            PDOUT = [score, r_lab, r_seq, c_lab, c_seq] + list(PDOUT)
            scoreLst.append(PDOUT)
    scoreLst.sort(lambda x,y:cmp(x[0],y[0]))
    maxPDOUT = scoreLst[-1]
    return maxPDOUT


class MUXProject:
    def __init__(self, AmpObjLst, location, root = 'test'):
        self.root = root
        self.location = location
        self.subRoutineDir = location['subRoutineDir']
        self.UD = location['WorkDir']
        self.SM = None##CL.SimilarityMatrix(Similarity = 0, MAX = None, MIN = None)
        self.pairDBLL = ['score', 'r_lab', 'r_seq', 'c_lab', 'c_seq', 'energy', 'testSeq', 'otherProbe', 'queryHitSeq', 'subjectHitSeq', 'distFromEnd', 'testSeqLength']
        self.pairDB = []
        self.outDB = []
        self.AmpObjLst = []
        self.AddAmplicons(AmpObjLst)
        self.n = len(self.AmpObjLst)
    def AddAmplicons(self, ampobjLst):
        for ampobj in ampobjLst:
            if 'PCRAmplicon' in str(ampobj):
                self.AmpObjLst.append(ampobj)
            else:
                ampLabel, ampSeq, forLabel, forPrimer, revLabel, revPrimer = ampobj[:6]
                print 'Creating amplicon Object for %s' %ampLabel
                self.AmpObjLst.append(PCRAmplicon(ampLabel, ampSeq = ampSeq, forlabel = forLabel,Fprimer = forPrimer, revlabel = revLabel, Rprimer = revPrimer))
        self.n = len(self.AmpObjLst)
        print 'MUXProject object has %i amplicons' %self.n
    def runme(self):
        self.GenerateSM()
        self.GenerateOutDB()
        PairDB_IFN = self.export_PairDB()
        SMDB_IFN = self.export_AmpObjLst()
        return PairDB_IFN, SMDB_IFN
    
    def GenerateSM(self):
        self.pairDB = []
        self.SM = CL.SimilarityMatrix(Similarity = 0, MAX = None, MIN = None)
        t = US.ReportTimer(len(self.AmpObjLst), ReportInterval = 1, ProcessName = 'generating SW:')
        for r in range(len(self.AmpObjLst)):
            t(r)
            for c in range(len(self.AmpObjLst)):
                if r != c:#This prevents two amplicons from being compared to each other
                    maxPDOUT = ComputAmpObjPrimerDimer(self.AmpObjLst[r],self.AmpObjLst[c], location)
                    score = maxPDOUT[0]
                    self.pairDB.append(maxPDOUT)
                else:
                    score = 0.0
                self.SM[r][c] = score
        self.pairDB.sort(lambda x,y:cmp(x[0],y[0]))
        self.pairDB.reverse()
        
    def GenerateOutDB(self):        
        self.outDB = []
        HuReadable = self.SM.HumanReadable()
        for i in range(len(self.AmpObjLst)):
            outline = self.AmpObjLst[i].outDB() + ['Hit->' , i] +  HuReadable[i] 
            self.outDB.append(outline)
        self.AmpObj_LL = self.AmpObjLst[0].outDB(LL=1)
        self.AmpObj_LL.extend(['',''])
        self.AmpObj_LL.extend([i for i in range(self.SM.n)])
        
    def export_PairDB(self, ofn=None):
        if not(ofn):
            ofn = 'Pairdb_%s_T.txt'%self.root
        pairDB = [self.pairDBLL] + self.pairDB
        PairDB_IFN = FA.path([self.UD, ofn])
        PairDB_IFN.outDB(pairDB)
        return PairDB_IFN
    def export_AmpObjLst(self, ofn=None):
        if not(ofn):
            ofn = 'AmObjSM_%s_T.txt'%self.root
        outDB = [self.AmpObj_LL] + self.outDB
        SMDB_IFN = FA.path([self.UD, ofn])
        SMDB_IFN.outDB(outDB)
        return SMDB_IFN
    def CalculateMUXClusters(self, maxMUXScore = 40000):
        sm = self.SM.HumanReadable()
        smSize = self.SM.n
        self.clLst = []
        for i in range(smSize):
            self.clLst.append(minigroup(i, self.SM, cutoff = maxMUXScore))
        self.clLst.sort(lambda x,y:cmp(x.score,y.score))
        pairDB = self.generateMergerLst()
        while 1:
            merge = None
            for pair in pairDB:
                score, i, j, ce = pair
                if score == None: continue
                if score < maxMUXScore:
                    if DEBUG:print 'Merging %i with %i score will be %.2f  %s' %(i,j, score, ce)
                    if self.clLst[i].n and self.clLst[j].n:
                        self.clLst[i].Merge(self.clLst[j])
                        merge = 1
                        break
            if not(merge):
                break
            else:
                pairDB = self.generateMergerLst()
        oll = ['i', 'clNum', 'cl.score', 'cl.n']   
        outDB = []
        clNum = 0
        for cl in self.clLst:
            ret = cl.groupElemLst
            if ret:
                clNum +=1
                for i in ret:
                    outDB.append([i, clNum, cl.score, cl.n, cl.groupElemLst, cl])
        outDB.sort(lambda x,y:cmp(x[0], y[0]))
        print str(oll)
        for po in outDB:
            i, clNum, score, n, elemLst, cl = po 
            print '%i\t%i\t%i\t%i\t%s' %(i, clNum, score, n, str(cl.groupElemLst))
        OFN = FA.path([self.UD, 'MultiplexSets_%s_T.txt'%self.root])
        outDB = [oll] + outDB
        OFN.outDB(outDB)
        return OFN
    def generateMergerLst(self):
        #Property of MUXProject: CalculateMUXClusters
        clLst = self.clLst
        pairDB = []
        n = len(clLst)
        for i in range(n):
            for j in range(n):
                if i ==j: continue
                combinedElements = clLst[i].groupElemLst + clLst[j].groupElemLst
                pairDB.append([clLst[i].scorePossibleMerger(clLst[j]), i, j, combinedElements ])
        pairDB.sort(lambda x,y:cmp(x[0],y[0]))
        return pairDB


class minigroup:
    #Property of MUXProject: CalculateMUXClusters
    def __init__(self, index, SM, cutoff = 30000):
        self.cutoff = cutoff
        self.SM = SM
        self.index = index
        self.groupElemLst = [index]
        self.makeOneWayPairDB()
        self.score = LM.SumArr(self.pairdb, index = 1)
        self.countElements()
        self.n = 1
    def sm(self, i,j):
        val = max(0,self.SM.SparseLookup(i,j)-self.cutoff)
        return val
    def countElements(self):
        self.n = len(self.groupElemLst)
    def makeOneWayPairDB(self):
        self.pairdb = []
        for i in range(self.SM.n):
            self.pairdb.append([i, self.sm(self.index,i)])
        self.pairdb.sort()
    def scorePossibleMerger(self, mg):
        elemLst = copy.deepcopy(mg.groupElemLst)
        testgroup = copy.deepcopy(self.groupElemLst) 
        for elem in elemLst:
            if not(elem in testgroup):
                testgroup.append(elem)
        return self.scoreGroup(testgroup)
    def scoreSelfGroup(self):
        self.countElements()
        self.score = self.scoreGroup(self.groupElemLst)
    def scoreGroup(self, groupelements):
        if not(groupelements): return None
        score = 0.0
        scLst = []
        for i in groupelements:
            for j in groupelements:
                if i <>j:
                    scLst.append(self.sm(i,j))
        if scLst:
            score = max(scLst) #else return 0.0
        return score
    def Merge(self, mg):
        before = self.n + mg.n
        for elem in mg.groupElemLst:
            if not(elem in self.groupElemLst):
                self.groupElemLst.append(elem)
        mg.groupElemLst = []
        mg.scoreSelfGroup()
        self.scoreSelfGroup()
        aftertotalElements = self.n + mg.n
        if before != aftertotalElements:
            raise 'Huh??'
    def chooseMergerPartner(self, cutoff = None):
        if cutoff ==None:
            cutoff = self.cutoff
        for gr in self.pairDB:
            i, score = gr
        if score < cutoff:
            return i
        return None






if __name__ == '__main__':
    import FASTA as FA
    location = WORK = {'subRoutineDir':os.getcwd()+'/', #
        'WorkDir' : os.getcwd()+'/test/'}
    testUD = location['WorkDir']
    INF_FA = FA.path([testUD,'primer3_test_fa.txt'], fileType = 'fasta')
    SettingsDict = {
        'PRIMER_PRODUCT_SIZE_RANGE':'180-250',
        'PRIMER_OPT_SIZE':'19',
        'PRIMER_MIN_SIZE':'17',
        'PRIMER_MAX_SIZE':'25',
        'PRIMER_WARNING':'s (*)',
        'PRIMER_MIN_TM':'52',
        'PRIMER_OPT_TM':'55',
        'PRIMER_MAX_TM':'56',
        'PRIMER_TM_SANTALUCIA':'1',
        'PRIMER_SALT_CORRECTIONS':'1',
        'PRIMER_PRODUCT_TM_OLIGO_TM_DIFF':'1.0',
        'PRIMER_GC_CLAMP':'2',}

    primer3_OFN = RunPrimer3(INF_FA, location, INSettingsDict = SettingsDict, OFN_PATHorpath = None, root = 'UNITTEST')
    OFN = ParsePrimer3(primer3_OFN, location, InGetVals = [])

    ##Test MUX proceedures
    seq = 'aattggactggAGTCACT'.lower()
    ##        if pairdbOUT:
    ##        return 'nolabel', seq, 'nolabel', seq, energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, score
    ##    else:
    ##        return score, testSeq, otherProbe
    qs, qseq, ss, sseq, energy, testSeq, otherProbe, queryHitSeq, subjectHitSeq, distFromEnd, score = ComputeSelfPrimerDimer(seq, pairdbOUT= 1)
    print 'ComputeSelfPrimerDimer:\n%s seq has interaction of %.2f %s maps to %s' %(qs, score, testSeq, otherProbe)

    ampliconDB = [['nearINSIG2|rs7566605|gid51141', 'ACCCCATCGGAATTGAAATCATTGCAATAGCCACTGCCAAGTACTTAACAATGGATANNCTTTAGGTCTGTACCAGGGTGGTTTTCAGTTTTTTACTTCATCAGCACAGGAAGGCAAGGACATCGCACTGACTC', 'For|nearINSIG2|rs7566605|gid51141|sl-27-49', 'ACCCCATCGGAATTGAAATCAT', 'Rev|nearINSIG2|rs7566605|gid51141|sl-9-29', 'cgcgcGAGTCAGTGCGATGTCCTTG' ],
    ['TBC1D1|rs2279027|gid23216', 'GTGGTCAGGGAATGCACAGGCAGGGAGCCCACCAGCTGCAGGCCAAAATCCACCGAGACCTNNATGTTTCCTTGCTGTGAATGTTATTGGTTCCATCTTGGGAAGGGTCTGGGAACTCAGCAAAACAGTT', 'For|TBC1D1|rs2279027|gid23216|sl-23-42', 'GTGGTCAGGGAATGCACAG', 'Rev|TBC1D1|rs2279027|gid23216|sl-17-38', 'gcggccAACTGTTTTGCTGAGTTCCCA'],
    ['TBC1D1|rs4008480|gid23216', 'TTGACTTCTCCCTGGCTCAGGTTCACATCTCAGTCCAGAGGGTGAAACGCAAAGCCGGACTTGCTTGGTTACAGGTTCCNNGCCTGCTGAGTCTTCGCACCTCAGCCACAACCCAGGGCAGCATGGGCATGGTGGTCAGGGAATGCACAG', 'For|TBC1D1|rs4008480|gid23216|sl-5-24', 'TTGACTTCTCCCTGGCTCA', 'Rev|TBC1D1|rs4008480|gid23216|sl-15-34', 'gccggCTGTGCATTCCCTGACCAC'],
    ['TBC1D1|rs2279026|gid23216', 'ATCGGCTTTGAACACATAGCAGATACTCTGCCGNNTCCTTAATCAGACAAGCAAAGTAACTTGGGTCATGACTGTTGTGAATCAGTTTGTGAACACGCTG', 'For|TBC1D1|rs2279026|gid23216|sl-51-72', 'ATCGGCTTTGAACACATAGCA', 'Rev|TBC1D1|rs2279026|gid23216|sl-19-41', 'gcggcgCAGCGTGTTCACAAACTGATTC'],
    ['TBC1D1|rs10501|gid23216', 'AAGTTCAATCACGTCAGCGGCAGCCGGGGGTCCGAGAGCCCCCGCCCCAACCCGCCCCATGCCGCGCCCACAGGGAGCCAGGNNGCCCATGCGCAAGTCCTTCTCCCAGCCCGGCCTGCGCTCGCTGGCCTTTAGGAAGGAGCTGCAGGAT', 'For|TBC1D1|rs10501|gid23216|sl-2-22', 'AAGTTCAATCACGTCAGCGG', 'Rev|TBC1D1|rs10501|gid23216|sl-17-37', 'cgcgcATCCTGCAGCTCCTTCCTAA'],
                  ]
    
    muxObj = MUXProject([], location, root = 'unittest')
    ampLabel, ampSeq, forLabel, forPrimer, revLabel, revPrimer = ampliconDB[0][:6]
    ampliconDB.append(PCRAmplicon('ImportedAsObject_'+ampLabel, ampSeq = ampSeq, forlabel = forLabel,Fprimer = forPrimer, revlabel = revLabel, Rprimer = revPrimer))
    muxObj.AddAmplicons(ampliconDB)
    addObj = ['noamplicon', '', 'For|TBC1D1|rs2279027|gid23216|sl-23-42', 'GTGGTCAGGGAATGCACAG', 'Rev|TBC1D1|rs2279027|gid23216|sl-17-38', 'gcggccAACTGTTTTGCTGAGTTCCCA']
    muxObj.AddAmplicons([addObj])
    PairDB_IFN, SMDB_IFN = muxObj.runme()
    ofn = muxObj.CalculateMUXClusters(maxMUXScore = 40000)
    print 'now with a 30,000 limit'
    ofn = muxObj.CalculateMUXClusters(maxMUXScore = 30000)














##This is the deprecation line #####################################################

def AmpliconObjMUX(AmpObjLst, location, root = 'test'):
    ##Deprecated
    ##this has been stuffed into MUXProject
    #Usage:
    #SM, SMDB_IFN, PairDB_IFN = AmpliconObjMUX(AmpObjLst, location, root = 'test')
    subRoutineDir = location['subRoutineDir']
    UD = location['WorkDir']
    SM = CL.SimilarityMatrix(Similarity = 0, MAX = None, MIN = None)
    pairDB = [['score', 'r_lab', 'r_seq', 'c_lab', 'c_seq', 'energy', 'testSeq', 'otherProbe', 'queryHitSeq', 'subjectHitSeq', 'distFromEnd', 'testSeqLength']]
    
    t = US.ReportTimer(len(AmpObjLst), ReportInterval = 1, ProcessName = 'generating SW:')
    for r in range(len(AmpObjLst)):
        t(r)
        for c in range(len(AmpObjLst)):
            if r != c:#This prevents two amplicons from being compared to each other
                maxPDOUT = ComputAmpObjPrimerDimer(AmpObjLst[r],AmpObjLst[c], location)
                score = maxPDOUT[0]
                pairDB.append(maxPDOUT)
            else:
                score = 0.0
            SM[r][c] = score
            
    PairDB_IFN = FA.path([UD, 'Pairdb_%s_T.txt'%root])
    PairDB_IFN.outDB(pairDB)
    HuReadable = SM.HumanReadable()
    
    outDB_LL = AmpObjLst[0].outDB(LL=1)
    outDB = []
    for i in range(len(AmpObjLst)):
        outline = AmpObjLst[i].outDB() + ['Hit->' , i] +  HuReadable[i] 
        outDB.append(outline)
    

    outDB_LL.extend(['',''])
    outDB_LL.extend([i for i in range(SM.n)])
    outDB = [outDB_LL] + outDB
    
    SMDB_IFN = FA.path([UD, 'SM_%s_T.txt'%root])
    SMDB_IFN.outDB(outDB)
    return SM, SMDB_IFN, PairDB_IFN

def PCR(IFN, PrimerFN, UD, subRoutineDir, MinHitLength = 4, AlignCutOff = 10, ApproxFragSize = 300, Verbose = 1):
    """PCR:
    |Input: (IFN,PrimerFN,UD,MinHitLength = 4,AlignCutOff = 10,ApproxFragSize = 300, Verbose = 1)
    |Output: outFileName
    |Given set of FASTA seqs, and some primers, it figures out PCR products
    ||"""
    inDB = FA.InFASTANL(IFN,UD,Verbose = 1)
    primerDB = LM.InArray(PrimerFN,UD,separator = '\t',Verbose = 1)
    extra = 10
    #you'll need this later
    primerIndex = []
    for primerObj in primerDB:
        primerIndex.append(primerObj[0])
    defaultBLASTparams = {'p':'blastn','e':'100', 'm':'9', 'b':'100', 'F':'F','W':'7'}
    b = {'query':0,'subject':1,'%id':2,'align':3,'mm':4,'gap':5,'qstart':6,'qend':7,'sstart':8,'send':9,'e':10,'score':11}

    PCRObjList = [['Template', 'F_Primer', 'F_align', 'F_sstart', 'F_send', 'F_score', 'F_primer', 'F_Thit', 'F_maxScore', #
                    'R_Primer', 'R_align', 'R_sstart', 'R_send', 'R_score', 'R_primer', 'R_Thit', 'R_maxScore' #
                   ,'PCR_Frag', 'PCR_start', 'PCR_end', ]]
    BLASTparams = {'p':'blastn','e':'100', 'm':'9', 'b':'100', #
                       'W':'7','F':'""', 'E':'1','G':'1'}
    b = {'query':0,'subject':1,'%id':2,'align':3,'mm':4,'gap':5,'qstart':6,'qend':7,'sstart':8,'send':9,'e':10,'score':11}
     
    for seqObj in inDB:
    #def PCR(seqObj,
        # 1 fastaLstObj or INF as primers
        # 2 fastaLstObj or INF as sequences
        seqObj[0] = seqObj[0].replace(',','')
        ##RunBlast(QueryLstorFN, DBLstorFN, userDir, subRoutineDir, BlastParams = {}, CleanGarbage = None, Verbose = None)
        parseIFN, garbage = BL.RunBlast(primerDB, [seqObj], UD,subRoutineDir,BLASTparams, CleanGarbage = None, Verbose = None)
        if Verbose:
            print 'parsing: ' + seqObj[0]
        blastObj = BL.inBLASTOut(parseIFN,UD+'blast/', minHitLength = MinHitLength)
        forHits = []
        asforHits = []
        revHits = []
        asrevHits = []
        for hitObj in blastObj:
            hitObj[b['score']] = float(hitObj[b['score']])
            if hitObj[b['query']].find('F_') <> -1:
                if int(hitObj[b['sstart']]) < int(hitObj[b['send']]):
                    #this probe is hitting forwards
                    hitObj = hitObj + [1]
                    forHits.append(hitObj)
                else:
                    #this probe is hitting backwards
                    hitObj = hitObj + [0]
                    asforHits.append(hitObj)
            elif  hitObj[b['query']].find('R_') <> -1:
                if int(hitObj[b['sstart']]) > int(hitObj[b['send']]):
                    hitObj = hitObj + [1]
                    revHits.append(hitObj)
                else:
                    hitObj = hitObj + [0]
                    asrevHits.append(hitObj)#this means that this probe is hitting backwards
        #This is where version 4 is different it assumes your primer labelling is correct
        #assess and extract location data
        fList = FixedHitParser(forHits,b,alignCutOff = AlignCutOff)
        rList = FixedHitParser(revHits,b,alignCutOff = AlignCutOff)
        
        forHit, revHit = CompareForRev(fList,rList,b,approxFragSize = ApproxFragSize)
        forSpec = None
        revSpec = None
        if forHit <> None:
            forSpec = ExtractHit(forHit)
            revSpec = ExtractHit(revHit)
        ##raw_input('yo')
        #Create output String spec = ['query','align','sstart','send','score']
        if revSpec <> None and forSpec <> None:
            subjectSeq = seqObj[1]
            spec = forSpec[:]
            PrimerSeq = primerDB[primerIndex.index(spec[0])][1]
            
            SubjectSeq = getSeq(subjectSeq,[spec[2],spec[3]],extra)
            ForwardSpec = forSpec + [PrimerSeq,SubjectSeq]
            
            spec = revSpec[:]
            PrimerSeq = primerDB[primerIndex.index(spec[0])][1]
            SubjectSeq = getSeq(subjectSeq,[spec[2],spec[3]],extra)
            RevSpec = revSpec + [PrimerSeq,SubjectSeq]
            
            #If the two primers are not in correct relation to one another, then there is a problem
            forPCRstart = min(forSpec[2:4])
            revPCRstart = max(revSpec[2:4])
            
            PCRfrag = subjectSeq[forPCRstart:revPCRstart]

            PCRObj = [seqObj[0]] + ForwardSpec +[LM.MaxArr(forHits,b['score'])]+ RevSpec + [LM.MaxArr(revHits,b['score'])]+[PCRfrag,forPCRstart,revPCRstart]
        else:
            PCRObj = [seqObj[0],'No Match']
        PCRObjList.append(PCRObj)
        
    ouf = LM.OutArray(PCRObjList,'PCRoutData_'+IFN,UD,outType = '\t',Verbose = 1)
    return ouf
